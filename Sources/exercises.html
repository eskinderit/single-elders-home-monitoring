<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2022-11-29 Tue 15:47 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>&lrm;</title>
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
</style>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content" class="content">
<div id="outline-container-org4bdc7f0" class="outline-2">
<h2 id="org4bdc7f0"><span class="section-number-2">1.</span> Hadoop</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-orgdce2573" class="outline-3">
<h3 id="orgdce2573"><span class="section-number-3">1.1.</span> Arithmetic mean</h3>
<div class="outline-text-3" id="text-1-1">
<p>
<span class="timestamp-wrapper"><span class="timestamp">&lt;2022-11-22 Tue&gt;</span></span>
</p>
</div>
<div id="outline-container-org4732791" class="outline-4">
<h4 id="org4732791"><span class="section-number-4">1.1.1.</span> Goal</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
Compute the arithmetic mean of a sequence of floating point numbers.  The sequence is stored as a text file, one number per line.
</p>
</div>
</div>
<div id="outline-container-org63829d9" class="outline-4">
<h4 id="org63829d9"><span class="section-number-4">1.1.2.</span> Sequential method</h4>
<div class="outline-text-4" id="text-1-1-2">
<ul class="org-ul">
<li>Accumulate the count of numbers in \(\mathtt{count}\), and the sum of numbers in \(\mathtt{nsum}\)</li>
<li>Output \(\mathtt{nsum/count}\)</li>
</ul>
</div>
</div>
<div id="outline-container-org0dd99ef" class="outline-4">
<h4 id="org0dd99ef"><span class="section-number-4">1.1.3.</span> Hadoop method</h4>
<div class="outline-text-4" id="text-1-1-3">
<p>
Same
</p>
</div>
</div>
<div id="outline-container-org93330f4" class="outline-4">
<h4 id="org93330f4"><span class="section-number-4">1.1.4.</span> General observations</h4>
<div class="outline-text-4" id="text-1-1-4">
<p>
The key point is finding a way of separating the task into a map function and a reduce function.  In the method synopsis above, accumulation is the process of incrementing an object using a second one, then incrementing the result using a third object, and so on, as in
</p>
<div class="org-src-container">
<pre class="src src-python">for x in sequence:
    n += x
</pre>
</div>
<p>
which is identical to doing \(f(\ldots f(f(x_1, x_2), x_3)\ldots x_n)\), with  \(\mathtt{sequence} = (x_1, x_2, \ldots, x_n)\), which is a reduce functional.  Thus, both accumulations can be implemented in the reduce function.  The map function will have the sole purpose of creating one key-value pair for each number, with a constant arbitrary key, for example \(\mathtt{'0'}\), and a floating point number as value.
</p>
</div>
</div>
<div id="outline-container-org3cd8db0" class="outline-4">
<h4 id="org3cd8db0"><span class="section-number-4">1.1.5.</span> Remarks on implementation</h4>
<div class="outline-text-4" id="text-1-1-5">
<ul class="org-ul">
<li>Reuse the word count example.  In general, use a similar already working example as a template for the case at hand.</li>
<li>Write a graphical representation of your MapReduce flow.  In particular, write sample, or abstract, key-value pairs at the input of the reducer.  The design of the map function, the reduce function and its input space are interdependent and potentially part of a design loop.</li>
<li><p>
After designing the map and reduce algorithms, proceed gradually.  Implement one of the two functions function first, then test it initially with short input texts written by you.  Write texts with a text editor (for example the text editor you use for editing programs, like Visual Studio Code, or Spyder).  For example, to test the map function in our case, write a \(\mathtt{\text{data.txt}}\) text file like the following one:
</p>
<pre class="example" id="org0974add">
2.0
3.0
2.5
1.5
</pre>
<p>
Perform tests initially using purely Python in the Linux Bash shell (the default shell)
</p>
<div class="org-src-container">
<pre class="src src-bash">cat data.txt | python3 mapper.py 
</pre>
</div>
<p>
or, redirecting output and errors to a file, for example, \(\mathtt{\text{mapper_out.txt}}\)
</p>
<div class="org-src-container">
<pre class="src src-bash">cat data.txt | python3 mapper.py &amp;&gt; mapper_out.txt
</pre>
</div>
<p>
if the output is large, or you prefer to read the output in a text editor.  The \(\mathtt{\text{&>}}\) character sequence stands for output and error redirection in Bash:  output and error are not displayed, they are written to the specified file instead.
</p>

<p>
When you implement the reduce function, test it with short input texts written by you, simulating the format and content of the mapper's output.  For example, if the reduce function code separates input keys and values with a TAB character, then for our problem
</p>
<pre class="example" id="org01d3c2c">
0    2.0
0    3.0
0    2.5
0    1.5
</pre>
<p>
where the space between key and value is a TAB character in the text file.
Remember to implement the reduce function on the assumption that keys will be grouped by the Hadoop framework between map and reduce, and that the reduce function never receives partial key groups.  Concatenate the whole pipeline in Python, with a sorting stage between map and reduce.
</p>
<div class="org-src-container">
<pre class="src src-bash">cat data.txt | python3 mapper.py | sort | python3 reducer.py   
</pre>
</div>
<p>
Finally, test your code in Hadoop's standalone and pseudo-distributed mode.  The first two scripts in our class examples can be easily adapted to the present case, by changing the names of the input file and the output directory.
</p></li>

<li><p>
Do not conclude you program is correct after testing a few reasonable inputs.  Challenge your code by writing unusual, extreme, or pathological cases, such as cases in which
</p>
<ul class="org-ul">
<li>the entire input, or part of it, is empty</li>
<li>values are extremal, or zero.</li>
</ul>
<p>
Note that the set of unusual, extreme, or pathological cases varies with the problem.  Note also that testing such cases may help in clarifying what the assumptions about your inputs are &#x2014;ideally, they should have been clearly expressed in the problem statement, but often that is not the case.
</p></li>
<li>Remember to add comments to your code

<ul class="org-ul">
<li><p>
as multi-line comments, to explain the purpose of code lines that follow
</p>
<div class="org-src-container">
<pre class="src src-python"># find the position i of item in data
for i in range(len(data)):
    if data[i] == item:
        break
</pre>
</div></li>

<li><p>
or comments at the end of a line explaining the operation executed by that single line of code
</p>
<div class="org-src-container">
<pre class="src src-python">sq = [(x-mean)/std for x in data]  #normalise to 0 mean and 1 var
</pre>
</div></li>
</ul></li>

<li><p>
<i>Warning.</i>  In the map function, if the input text line containing the single floating point number (represented as a sequence of chars) is printed to output without modifications
</p>
<div class="org-src-container">
<pre class="src src-python">print('{0}\t{1}'.format('0', line))
</pre>
</div>
<p>
then two newline characters are printed for every output line, thus generating a blank line every two lines.  One newline character is contained in the line string, the other is printed by the print function.  Converting the number to a floatA simple workaround is
</p>
<div class="org-src-container">
<pre class="src src-python">print('{0}\t{1}'.format('0', float(line)))
</pre>
</div>
<p>
which converts the floating point number represented as a 
</p></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org3082377" class="outline-3">
<h3 id="org3082377"><span class="section-number-3">1.2.</span> Arithmetic mean by key</h3>
<div class="outline-text-3" id="text-1-2">
<p>
<span class="timestamp-wrapper"><span class="timestamp">&lt;2022-11-23 Wed&gt;</span></span>
</p>
</div>
<div id="outline-container-org0d92695" class="outline-4">
<h4 id="org0d92695"><span class="section-number-4">1.2.1.</span> Goal</h4>
<div class="outline-text-4" id="text-1-2-1">
<p>
Compute the arithmetic means of sequences of floating point numbers.  The sequences are stored as a single text file, in which every number of a sequence is written in a separate line, preceded by a key that is unique to the sequence.  The lines are not ordered by key.  Example:
</p>
<pre class="example" id="org5bfb945">
a 2.1
b 1.1
a .2
b 1.4
c 0.0
a 0.1
a -1.0
c -1.0
</pre>
</div>
</div>
<div id="outline-container-org61185d7" class="outline-4">
<h4 id="org61185d7"><span class="section-number-4">1.2.2.</span> Sequential method</h4>
<div class="outline-text-4" id="text-1-2-2">
<p>
For each input line
</p>
<ul class="org-ul">
<li>Search for a triplet \(\mathtt{key},\mathtt{count},\mathtt{nsum}\), where \(\mathtt{key}\) is the key in the line</li>
<li>If the triplet has been found, increment its \(\mathtt{count}\) and add the number in the line to its \(\mathtt{nsum}\)</li>
<li>If a triplet has not been found, create one as \(\mathtt{key},1,\mathtt{n}\), where  \(\mathtt{n}\) is the number in the line</li>
</ul>
<p>
For each triple, output \(\mathtt{key},\mathtt{nsum/count}\)
</p>
</div>
</div>
<div id="outline-container-org38ecaeb" class="outline-4">
<h4 id="org38ecaeb"><span class="section-number-4">1.2.3.</span> General observations</h4>
<div class="outline-text-4" id="text-1-2-3">
<p>
As in the previous example, accumulations will be performed by the reducer, which, in this case, must separate accumulations by key.  Since the reducer's input is key sorted, it suffices to remember the last key and output the result when the key changes.  
Each key-value pair is written on a separate line, thus the map function copies each line to its output.
</p>
</div>
</div>
<div id="outline-container-org925693d" class="outline-4">
<h4 id="org925693d"><span class="section-number-4">1.2.4.</span> Remarks on implementation</h4>
<div class="outline-text-4" id="text-1-2-4">
<p>
The general suggestions of the previous case apply.  Additional tips:
</p>
<ul class="org-ul">
<li><p>
Since the map function is a key-value copy, you can test the reduce function on the input file, if the reduce function splits a line using one or multiple spaces, which is the default for the \(\mathtt{split}\) function without separator specification:
</p>
<div class="org-src-container">
<pre class="src src-python">st = "Two really       long        spaces."
print(st.split())
</pre>
</div>

<pre class="example">
['Two', 'really', 'long', 'spaces.']
</pre></li>

<li>The map function should use the \(\mathtt{\text{end=''}}\) option of \(\mathtt{print}\) for writing to output, if input lines are copied to output verbatim.  In fact, input lines end with an end-of-line that adds to the one \(\mathtt{print}\) writes by default.</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org91caf3e" class="outline-3">
<h3 id="org91caf3e"><span class="section-number-3">1.3.</span> Variance by key</h3>
<div class="outline-text-3" id="text-1-3">
<p>
<span class="timestamp-wrapper"><span class="timestamp">&lt;2022-11-26 Sat&gt;</span></span>
</p>
</div>
<div id="outline-container-org4738901" class="outline-4">
<h4 id="org4738901"><span class="section-number-4">1.3.1.</span> Goal</h4>
<div class="outline-text-4" id="text-1-3-1">
<p>
Compute the variance of sequences of floating point vectors on the axes.  The sequences are stored as a single text file, in which every vector of a sequence is written in a separate line, preceded by a key that is unique to the sequence.  The lines are not ordered by key.  Example:
</p>
<pre class="example" id="org0143dc5">
a 2.1 1.0
b 1.1 2.0
a .2  2.0
b 1.4 3.8
c 0.0 -1.0
a 0.1 -1.0
a -1.0 -1.0 
c -1.0 1.0
</pre>
</div>
</div>
<div id="outline-container-org8ccc3b9" class="outline-4">
<h4 id="org8ccc3b9"><span class="section-number-4">1.3.2.</span> Sequential method and Python implementation</h4>
<div class="outline-text-4" id="text-1-3-2">
<p>
Let \(p\) be the vector length.  For each key \(k\), let \(V_k\) be the corresponding set of vectors in input.  For any key \(k\), a \((2p+2)\)-tuple \(k, |V_k|, \sum_{\mathbf{v}\in V_k} \mathbf{v}, \sum_{\mathbf{v}\in V_k} (v_1^2,\ldots,v_p^2)\), where \(\mathbf{v} = (v_1,\ldots,v_p)\), is maintained.
</p>

<p>
For each input line
</p>
<ul class="org-ul">
<li>Search for a \((2p+2)\)-tuple \(\mathtt{key},\mathtt{count},\mathtt{vecsum}, \mathtt{sqsum}\), where \(\mathtt{key}\) is the key in the line</li>
<li>If the triplet has been found, increment its \(\mathtt{count}\) and add the vector in the line component-wise to its \(\mathtt{vecsum}\), and the squares of the components the vector component-wise to its \(\mathtt{sqsum}\)</li>
<li>If a triplet has not been found, create one as \(\mathtt{key},1,\mathtt{vec}, \mathtt{sqvec}\), where  \(\mathtt{vec}\) is the vector in the line, and \(\mathtt{sqvec}\) is the vector of the squares of the components of \(\mathtt{vec}\)</li>
</ul>
<p>
For each tuple \(\mathtt{key},\mathtt{count},\mathtt{vecsum}, \mathtt{sqsum}\), output
</p>

<p>
\[ \mathtt{key}, \mathtt{sqsum}/\mathtt{count}-(\mathtt{vecsum}/\mathtt{count})^2 \]
</p>

<p>
where all operations are computed component-wise.
</p>

<div class="org-src-container">
<pre class="src src-python"># -*- coding: utf-8 -*-
"""
Created on Fri Nov 25 22:49:07 2022

@author: s

Component-wise variances of vectors.
Accumulations in a single flat list.
"""
import sys

acc = []  #accumulations as key, count, v sum, square sum
for line in sys.stdin:
    # print(line)
    vec = line.split()   # split as key and components into list
    key = vec[0]
    coord = [float(e) for e in vec[1:]]   # coordinates to float
    found = False
    for i in range(len(acc)):
        if acc[i][0] == key:              # key found
            found = True
            break
    if found:
        a = acc[i]
        sq_offset = len(a)//2 + 1         # index of first square
        a[1] += 1
        for k in range(len(coord)):
            a[k+2] += coord[k]
            a[k+sq_offset] += coord[k]**2
    else:
        acc.append([key, 1] + coord + [x**2 for x in coord])
# variances on axes
for a in acc:
    sq_offset = len(a)//2 + 1
    c = a[1]
    print(a[0], *[a[k+sq_offset]/c - (a[k+2]/c)**2 for k in range(len(a)//2-1)])
</pre>
</div>
<div class="org-src-container">
<pre class="src src-python"># -*- coding: utf-8 -*-
"""
Created on Fri Nov 25 22:49:07 2022

@author: s

Component-wise variances of vectors.
Accumulations of counts, coordinates,
and squared coordinates in separate dictionaries.
"""
import sys

counts = {}
sums = {}
sqsums = {}
for line in sys.stdin:
    vec = line.split()   # split as key and components into list
    key = vec[0]
    coord = [float(e) for e in vec[1:]]   # coordinates to float
    sqcoord = [x**2 for x in coord]
    counts[key] = counts.setdefault(key, 0) + 1
    sums[key] = [a+b for a, b in zip(sums.setdefault(key, [0]*len(coord)), coord)]
    sqsums[key] = [a+b for a, b in zip(sqsums.setdefault(key, [0]*len(sqcoord)), sqcoord)]
# variances on axes
for key in counts.keys():
    print(key, *[sq/counts[key]-(s/counts[key])**2 for s, sq in zip(sums[key], sqsums[key])])
</pre>
</div>
</div>
</div>
<div id="outline-container-orgbcbf33e" class="outline-4">
<h4 id="orgbcbf33e"><span class="section-number-4">1.3.3.</span> General observations</h4>
<div class="outline-text-4" id="text-1-3-3">
<p>
The main differences with respect to the previous examples lie in dimensionality&#x2014;in this case, it is arbitrary&#x2014;and squares, which are required to compute variance.  The reduce function accumulates coordinate values and coordinate squares component-wise.  As in the arithmetic mean by key, the search logic is replaced by a simple test on key change, because the framework groups by key.
</p>
</div>
</div>
<div id="outline-container-orgc280cd4" class="outline-4">
<h4 id="orgc280cd4"><span class="section-number-4">1.3.4.</span> Remarks on implementation</h4>
<div class="outline-text-4" id="text-1-3-4">
<ul class="org-ul">
<li>The map function copies lines to output (use \(\mathtt{\text{end=''}}\) in the print function to avoid double newline characters).</li>
<li>The reduce function is similar in its key processing logic to the one in the previous example.  However, looping over \(\mathtt{print}\) function calls to write thehh variances to output is easier than trying to use format, as the number of arguments equals the dimensionality, which depends on the data.  All variances for a key should be output in the same line:  an \(\mathtt{\text{end='\t'}}\) second argument to \(\mathtt{print}\) replaces the default newline character with the TAB character, thereby keeping the values in the same line, and a \(\mathtt{print()}\) after the loop ends a line.
<i>Note.</i> Computing squares in the mapper is also possible, but note that it would almost double the data size.</li>
<li>The <a href="#org4732791">example text above</a> could be used for initial testing, comparing the  result with the output of the sequential implementations.</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org84b6d00" class="outline-3">
<h3 id="org84b6d00"><span class="section-number-3">1.4.</span> K-means</h3>
<div class="outline-text-3" id="text-1-4">
<p>
<span class="timestamp-wrapper"><span class="timestamp">&lt;2022-11-27 Sun&gt;</span></span>
</p>
</div>
<div id="outline-container-orgc949f34" class="outline-4">
<h4 id="orgc949f34"><span class="section-number-4">1.4.1.</span> Goal</h4>
<div class="outline-text-4" id="text-1-4-1">
<p>
Given a dataset of same dimensionality vectors, compute the K-means clustering of the set.
</p>

<p>
<i>Note.</i>
Partitional clustering algorithm <b>K-means</b> is a fast heuristic algorithm to minimise the sum of all within-cluster squared distances of patterns:
</p>
\begin{equation*}
W(C) = \sum_{k=1}^K \,\sum_{\substack{i\leq N\\j\leq N\\k=C(i)=C(j)}} d^2(x_i, x_j)
\end{equation*}
<p>
where \(N\) is the number of patterns in the data, \(K\) is the number of clusters and \(C\colon \{1,\ldots,N\} \to \{1,\ldots,K\}\) is the assignment function from pattern indices to cluster indices, also termed <b>encoder</b>.  The algorithm converges to a local minimum of \(W(C)\). 
</p>

<p>
<i>Algorithm.</i> <a id="org7de88bd"></a>
</p>
<ol class="org-ol">
<li>Start with any set of \(K\) patterns as cluster centers</li>
<li>Assign each pattern to the nearest center</li>
<li>Recompute the centers</li>
<li>If the centers have not changed, halt.  Otherwise go to Step 1</li>
</ol>
</div>
</div>
<div id="outline-container-org1dfacc1" class="outline-4">
<h4 id="org1dfacc1"><span class="section-number-4">1.4.2.</span> Sequential method and Python implementation</h4>
<div class="outline-text-4" id="text-1-4-2">
<ul class="org-ul">
<li>Create a random sequence \(\mathtt{\text{centers}}\) of \(K\) cluster centers</li>
<li>Create two sequences \(\mathtt{\text{counts}}\) and \(\mathtt{\text{sums}}\) with \(K\) positions</li>
<li>Create an \(\mathtt{\text{encoder}}\) sequence with as many positions as there are patterns in the dataset</li>
<li><p>
Repeat
</p>
<ul class="org-ul">
<li>For each position \(\mathtt{\text{i}}\) in the dataset
<ul class="org-ul">
<li>Get the pattern \(\mathtt{\text{x}}\) at position \(\mathtt{\text{i}}\)</li>
<li>Find the index \(\mathtt{\text{nst_id}}\) of its closest center \(\mathtt{\text{c}}\) in \(\mathtt{\text{centers}}\)</li>
<li>Set position \(\mathtt{\text{i}}\) in \(\mathtt{\text{encoder}}\) to \(\mathtt{\text{nst_id}}\)</li>
<li>Increment position \(\mathtt{\text{nst_id}}\) in \(\mathtt{\text{count}}\)</li>
<li>Add \(\mathtt{\text{x}}\) component-wise to the sum vector at position \(\mathtt{\text{nst_id}}\) of \(\mathtt{\text{sums}}\)</li>
<li>Recompute \(\mathtt{\text{centers}}\) using \(\mathtt{\text{counts}}\), \(\mathtt{\text{sums}}\)</li>
</ul></li>
</ul>
<p>
until \(\mathtt{\text{centers}}\) have not changed      
</p></li>
</ul>

<div class="org-src-container">
<pre class="src src-python">import random

def sq_sum(x):
    return sum(y**2 for y in x)

def sq_norm_diff(x, y):
    return sq_sum(a-b for a, b in zip(x, y))

def init_centers(d, k):
    random.seed(1234567890)  # set a seed for testing
    extremes = [(min(x), max(x)) for x in zip(*d)]  # get coord ranges
    return [[random.uniform(*extremes[i]) for i in range(len(d[0]))]
            for j in range(k)]
</pre>
</div>
<div class="org-src-container">
<pre class="src src-python">from kmeans_functions import sq_norm_diff

def k_means(d, k, centers):
    dim = len(d[0])    # dimensionality
    last_centers = centers[:-1] + [[x+1 for x in centers[-1]]]
    encoder = [-1] * len(d)
    while centers != last_centers:
        sums = [ [0] * dim ] * k
        counts = [0] * k
        for i in range(len(d)):
            x = d[i]
            sq_diffs = [sq_norm_diff(x, c) for c in centers]
            nst_id = sq_diffs.index(min(sq_diffs)) # closest center
            encoder[i] = nst_id                    # update encoder
            sums[nst_id] = [x+y for x, y in zip(sums[nst_id], x)] # update stats
            counts[nst_id] += 1
        last_centers = centers.copy()
        for c in range(k):
            if counts[c] != 0:
                centers[c] = [s/counts[c] for s in sums[c]]
    return centers, encoder
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb1b25e5" class="outline-4">
<h4 id="orgb1b25e5"><span class="section-number-4">1.4.3.</span> General observations</h4>
<div class="outline-text-4" id="text-1-4-3">
<p>
Both steps 2 and 3 of the <a href="#org7de88bd">algorithm</a> require some form of accumulation, but only Step 3 requires a reduction step.
Step 2 computes minima over distances from each dataset pattern to centers.  As the number \(K\) of centers is negligible, for each dataset pattern the map function can easily find the closest center sequentially and write its index to output as key, then write the feature values of the pattern.  The reduce function accumulates all feature values for a center component-wise, and counts them.  When there are no more input lines for a center, the reducer computes the center and writes it to output.
</p>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Created: 2022-11-29 Tue 15:47</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
